#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
int main()
{
    //大端存和小端存
    //大端存δＪ剑菏侵的低位保存在却娴母叩刂分校而的高位保存在却娴牡偷刂分
    //小端存δＪ剑菏侵的低位保存在却娴牡偷刂分校而的高位保存在却娴母叩刂分
    int a = 255;  // 在w的存π问椋0a 00 00 00
    //10的二M位形式0000 0000 0000 1010，也就是00 00 00 0a （淖笸右由高到低）
    //但是H存放的形式是0a 00 00 00，所以@N是大端存δＪ

//一程式，判嘧止序的大端是小端


    char *p = &a;//只要a<128就可以正_判
    if(*p == a)
    {
        printf("大端\n");
    }
    else
    {
        printf("小端\n");
    }



//求以下程式的出Y果
    char a1 = -1;
    signed char a2 = -1;
    unsigned char a3 = -1;
    printf("int a1:%d\nint a2:%d\nint a3:%d\n",a1,a2,a3);

//解：

//原a：最高位是正值，其他是正常二M制担ㄕ是0，是1）
//反a：把原a最高位（符位）不，其他位按位取反
//aa：反a+1得到aa
//例如：
//原a---> 1000 0000 0000 0000 0000 0000 1110
//反a---> 1111 1111 1111 1111 1111 1111 0001
//aa---> 1111 1111 1111 1111 1111 1111 0010
//aa是在Xe面的存放的形式
//正档脑a就是aa，挡乓M行上面的算

//整-1在w中Υ嫘问1111 1111 1111 1111 1111 1111 1111 1111
//因char本身只有1字，所以在Υ-1（aa）r，是以1111 1111的形式,只取最後8位，前面的G掉
//同理signed char和unsigned char也是一
//m然Υ嬖谟w中的（aa）形式相同，但是在打印成整r（解a）r^程不同
//char和signed char是在前面a符位（@e的符位1），11111111111111111111111111111111
//但是unsigned char因楸旧]有符位，所以a0，也就是00000000000000000000000011111111
//最後翻g成原a的Y果 -1  -1  255  （最後一如果以%d形式打印的，第一位就是符位（0）所以原a和aa相同）

    char b = -128;
    printf("unsigned int b = %u\n",b);
//解：
//整-128 原a 1000 0000 0000 0000 0000 0000 1000 0000
//在w中Υ嫘问 1111 1111 1111 1111 1111 1111 1000 0000
//存Φchare面 1000 0000
//在以%u形式x取r，先要用整形提升，也就是用符位aR前面的位置
//Y果 1111 1111 1111 1111 1111 1111 1000 0000
//如果是%d的要M行解a操作，但是@e是以%u的形式，所以最高位不是符位，它本身就被J槭且正
//所以直接把 1111 1111 1111 1111 1111 1111 1000 0000打印出恚ㄊM制4,294,967,168）



    /*
    unsigned int c;
    for(c = 9;c>=0;c--){
        printf("%u\n",c);
        Sleep(500);
    }
    */

//解：
//出Y果9 8 7 6 5 4 3 2 1 0 4294967295 4294967294...
//因c是unsigned int型，所以在0之後再p1成4294967295
//unsigned int的值永h大於等於0，所以M入死循h




    char arr[1000];
    for(int i = 0; i<1000; i++)
    {
        arr[i] = -1-i;
    }
    printf("strlen of arr = %d\n",strlen(arr));


//解：
//strlen是去找到\0的位置，如果在字符串中有一值0，tstrlen只找到那位置之前的L度
//arr-1(-1-0)_始
//1111 1111  -->  -1
//1111 1110
//1111 1101
//...
//1000 0000  -->  -128
//0111 1111  -->  127
//0111 1110
//...
//0000 0001
//0000 0000  -->  0
//到0Y束
//所以字符串L度是128+127=255
//



//浮c丹未
//浮c荡κ且(-1)^s * M * 2^E 的形式
//如果是正担s = 0，如果是 s = 1
//M是把浮c蹈某啥M制K移又[1,2)e後小迭c後面的
//E是浮c蹈某啥M制K移又[1,2)er移拥奈,但是！！！
//Eunsigned型，在0-255，但是在HΥr，E等於原本的+127
//在32位w中第1位是s（共1位），第2-9位是E（共8位），第10-32位是M（共23位）
//在64位w中第1位是s（共1位），第2-12位是E（共11位），第13-64位是M（共52位）
//具w看以下例子

    float e = 5.5;
//先把小迭c前的整缔D成二M制5 --> 101
//再D小迭c後的  0.5 --> 0.1(@的0.1是指2^-1,K不是真的0.1)
//合起硎101.1
//然後移拥[1,2)e  --> 1.011*2^2
//改成(-1)^s * M * 2^E 的形式的就是：(-1)^0*1.011*2^(2+127)
//s = 0 , M = 0110 0000 0000 0000 0000 000 , E = 1000 0001   (共32位)
//在w中存放的序s-E-M
//也就是0100 0000 1011 0000 0000 0000 0000 0000
//@示在w中16M制也就是 40 b0 00 00
//大端存Φ脑就是00 00 b0 40


int f = 9;
float *pfloat = (float*)&f;
printf("int f = %d\n",f);
printf("float* pfloat = %f\n",*pfloat);
*pfloat = 9.0;
printf("int f = %d\n",f);
printf("float* pfloat = %f\n",*pfloat);


//解：
//int f = 9 在w中Υ娴男问 0000 0000 0000 0000 0000 0000 0000 1001
//如果以float的形式解a的就是 0 0000 0000 0000 0000 0000 0000 0001 001
//也就是s = 0 E = 0 M = 0000 0000 0000 0000 0001 001
//@e的E是-127+127的Y果，所以本身是2^-127
//所以@底址浅Ｐ。用浮c当硎揪褪0.000000，也就是printf("float* pfloat = %f\n",*pfloat);的Y果
//
//^*pfloat = 9.0;之後，Υ嬖f中的底职l生了改，成了9.0以浮c档男问Υ
//9.0 --> 1001.0 --> 1.001*2^3
//s = 0 , E = 3+127（1000 0010） , M = 001 0000 0000 0000 0000 0000
//也就是0100 0001 0001 0000 0000 0000 0000 0000
//以十M制形式打印就是1,091,567,616




















    return 0;
}
